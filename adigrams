#!/usr/bin/env python3

import optparse
import os
import sys


CAP = '+'
ROUND = '*'
CORNERS = {CAP, ROUND}
ERR = '?'

HORIZONTAL = ('-', '_' ,'=',)
VERTICAL = ('|', '!', 'H',)

N, E, S, W = 0, 1, 2, 3

GLYPHS = '''
╴ 0001   ╸ 0002   ╷ 0010   ┐ 0011   ┑ 0012   ╕ 0013   ╻ 0020   ┒ 0021
┓ 0022   ╖ 0031   ╗ 0033   ╮ 0044   ╶ 0100   ─ 0101   ╾ 0102   ┌ 0110
┬ 0111   ┭ 0112   ┎ 0120   ┰ 0121   ┱ 0122   ╓ 0130   ╥ 0131   ╺ 0200
╼ 0201   ━ 0202   ┍ 0210   ┮ 0211   ┯ 0212   ┏ 0220   ┲ 0221   ┳ 0222
═ 0303   ╒ 0310   ╤ 0313   ╔ 0330   ╦ 0333   ╭ 0440   ╵ 1000   ┘ 1001
┙ 1002   ╛ 1003   │ 1010   ┤ 1011   ┥ 1012   ╡ 1013   ╽ 1020   ┧ 1021
┪ 1022   └ 1100   ┴ 1101   ┵ 1102   ├ 1110   ┼ 1111   ┽ 1112   ┟ 1120
╁ 1121   ╅ 1122   ┕ 1200   ┶ 1201   ┷ 1202   ┝ 1210   ┾ 1211   ┿ 1212
┢ 1220   ╆ 1221   ╈ 1222   ╘ 1300   ╧ 1303   ╞ 1310   ╪ 1313   ╹ 2000
┚ 2001   ┛ 2002   ╿ 2010   ┦ 2011   ┩ 2012   ┃ 2020   ┨ 2021   ┫ 2022
┖ 2100   ┸ 2101   ┹ 2102   ┞ 2110   ╀ 2111   ╃ 2112   ┠ 2120   ╂ 2121
╉ 2122   ┗ 2200   ┺ 2201   ┻ 2202   ┡ 2210   ╄ 2211   ╇ 2212   ┣ 2220
╊ 2221   ╋ 2222   ╜ 3001   ╝ 3003   ║ 3030   ╢ 3031   ╣ 3033   ╙ 3100
╨ 3101   ╟ 3130   ╫ 3131   ╚ 3300   ╩ 3303   ╠ 3330   ╬ 3333   ╯ 4004
╰ 4400   ┄ TODO   ┅ TODO   ┆ TODO   ┇ TODO   ┈ TODO   ┉ TODO   ┊ TODO
┋ TODO   ╌ TODO   ╍ TODO   ╎ TODO   ╏ TODO   ╱ TODO   ╲ TODO   ╳ TODO
'''


def build_unicode_lookup_table():
    table = dict()
    tokens = GLYPHS.split()
    for i in range(0, len(tokens), 2):
        glyph, pattern = tokens[i:i+2]
        if pattern == 'TODO':
            continue
        pattern = tuple(map(int, pattern))
        table[pattern] = glyph
    return table


def visit(grid):
    for y, row in enumerate(grid):
        for x, char in enumerate(row):
            yield (x, y), char


def neighbours(p):
    x, y = p
    yield (x, y - 1)
    yield (x, y + 1)
    yield (x + 1, y)
    yield (x - 1, y)


def convert(block):
    grid = [list(l) for l in block.splitlines()]
    bmp = dict()

    for p, char in visit(grid):
        bmp[p] = [0, 0, 0, 0]
        if char in HORIZONTAL:
            weight = HORIZONTAL.index(char) + 1
            bmp[p][E] = bmp[p][W] = weight
        elif char in VERTICAL:
            weight = VERTICAL.index(char) + 1
            bmp[p][N] = bmp[p][S] = weight

    for p, char in visit(grid):
        if char in CORNERS:
            bmp[p] = [0, 0, 0, 0]
            x, y = p
            n, s, e, w = neighbours(p)
            if n in bmp: bmp[p][N] = bmp[n][S]
            if s in bmp: bmp[p][S] = bmp[s][N]
            if e in bmp: bmp[p][E] = bmp[e][W]
            if w in bmp: bmp[p][W] = bmp[w][E]
            if char == ROUND:
                bmp[p] = list(4 if v else 0 for v in bmp[p])

    # Delete lines that are only 1 grid space long / have no neighbouring bits
    for p, quad in tuple(bmp.items()):
        has_neighbour = False
        x, y = p
        n, s, e, w = neighbours(p)
        if quad[N] and n in bmp and bmp[n][S]:
            continue
        elif quad[S] and s in bmp and bmp[s][N]:
            continue
        elif quad[E] and e in bmp and bmp[e][W]:
            continue
        elif quad[W] and w in bmp and bmp[w][E]:
            continue
        del bmp[p]

    glyphs = build_unicode_lookup_table()
    for p, quad in bmp.items():
        if quad == [0, 0, 0, 0]: continue
        x, y = p
        glyph = glyphs.get(tuple(quad), ERR)
        grid[y][x] = glyph

    return '\n'.join(''.join(line) for line in grid)


def test():
    if not os.path.exists('README.md'):
        print('cannot find README.md in current directory; skipping tests')
        return
    with open('README.md') as f:
        readme = f.read()
    _, examples = readme.split('## Examples')
    paragraphs = examples.strip().split('```')
    while len(paragraphs) >= 4:
        _, test_data, _, expected, *paragraphs = paragraphs
        actual = convert(test_data)
        if actual.strip() == expected.strip():
            continue
        disaster = ''
        for e, a in zip(expected, actual):
            if e == a:
                disaster += e
            else:
                disaster += f'\033[032m{e}\033[031m{a}\033[0m'
        print('FAILED\n', disaster)


if __name__ == '__main__':
    parser = optparse.OptionParser()
    parser.add_option('--test', action='store_true')
    options, args = parser.parse_args()

    if options.test:
        test()
    else:
        if args:
            ios = map(open, args)
        else:
            ios = [sys.stdin]
        for io in ios:
            print(convert(io.read()))
